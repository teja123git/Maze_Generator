import numpy as np
import pytest
from app import ALGORITHMS # We import the algorithm dictionary from our main app.

def is_fully_connected(grid):
    """
    Checks if all path cells (value=1) are connected using a Breadth-First Search (BFS).
    This is a classic graph traversal algorithm.
    """
    height, width = grid.shape
    # Find all cells that are supposed to be paths
    path_cells = list(map(tuple, np.argwhere(grid == 1)))
    
    # If there are no path cells, the maze is technically connected.
    if not path_cells:
        return True
    
    # Start a traversal from the first path cell found
    start_node = path_cells[0]
    queue = [start_node]
    visited = {start_node}
    
    while queue:
        r, c = queue.pop(0)
        # Check all four neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            # If the neighbor is within bounds, is a path, and hasn't been visited...
            if 0 <= nr < height and 0 <= nc < width and grid[nr, nc] == 1 and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))
    
    # The maze is fully connected if the number of visited cells equals the total number of path cells.
    return len(visited) == len(path_cells)

# This is a parametrized test. Pytest will automatically run this function once for each algorithm.
@pytest.mark.parametrize("algo_name, algo_func", ALGORITHMS.items())
def test_maze_is_fully_connected(algo_name, algo_func):
    """Tests that every generated maze is valid and fully connected."""
    # Create a small, empty grid for testing
    grid = np.zeros((21, 21), dtype=np.int8)
    
    # Run the chosen algorithm's generator to completion to create the full maze
    for _ in algo_func(grid):
        pass
    
    # The 'assert' keyword is the core of the test. If the condition is false, the test fails.
    assert is_fully_connected(grid), f"Maze generated by {algo_name} is not fully connected!"
